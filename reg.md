

## JavaScript 通过内置对象 RegExp 支持正则 表达式 ##

### 有两种方法实例化RegExp对象 ###

* 字面量

* 构造函数

**字面量**

**\b**  单词边界;

> var reg  = / \ bis\b/g ;

> 'he is a boy. this is a dog .where  is she?' . replace( reg ,  "IS"); 

> he IS a boy. this IS a dog .where IS she;

> 会全部替换 IS

>  var reg = new RegExp ('\\bis\\b', 'g');

> he IS a boy. this IS a dog .where IS she;

> 会全部替换 IS;


## **修饰符**

* g : **global 全文搜索, 不添加, 搜索	到 第一个匹配停止** ;
* i  :  **ignore case 忽略大小写 默认大小写敏感**;
>'he is a boy. this Is a dog .where  is she?' . replace( /\bis\b/ gi,  0"); 

* m : **multiple lines 多行搜索**


##元字符

- 正则表达式由两种基本字符类型组成

        原义文本字符 
        a b c  d e f g 
        元字符

## 元字符是在正则表达式中	特殊含义的非字面字符 ##


#### 元字符 ####
一个
>  \ * ? ( ) { }  [ ]  

| 字符        | 含义           |
| ------------- |:-------------:| 
|  \t     | 水平制表符 | 
| \v      | 垂直制表符      |  
| \n | 换行符   |    
| \r | 回车符|
|\0  |空字符|
|\f|换页符|

|\cX|与X对应的控制字符(Ctrl +x)|

## 字符类 
- 一般情况下正则表达式一个字符对应字符串一个字符;
- 表达式 ab\t 的含义是 'ab'  tab;
-  我们可以使用元字符 [ ] 来构建一个简单的类;
-  所谓类是指符合某些特性的对象，一个泛指，而不是特指某个字符;
-  我们可以使用元字符 [ ] 来构建一个简单的类;
-  所谓类是指符合某些特性的对象，一个泛指，而不是特指某个字符;
-  表达式[abc] 把字符 a 或 b 或 c 归为一列,表达式可以匹配这类的字符;

		"a1b2c3d4".replace(/[abc]/g,"X");
		"X1X2X3d4"


##### 字符类取反 
- 使用元字符 ^ 创建 (反向类/负向类);
- 反向类的意思是不属于某类的内容;
- 表达式[ ^abc] 表示 不是字符 a或b或c 的内容;

		"a1b2c3d4".replace(/[^abc]/g,"X");
		"aXbXcXXX"	

#####范围类  ####
- 使用字符类匹配数字[0123456789];
- 正则表达式还提供了范围类;
- 所我们可以使用[a-z] 来连续两个字符表示(从 a-z 的任意字符);
- 这是一个闭区间,也就是包含a 和 z本身;

			'a1b2d3x4z9'.replace(/[a-z]/g,"Q");
			'Q1Q2Q3Q4Q9'

- 在[ ] 组成的类内部是可以连写的[a-zA-Z];
  
			'a1b2d3x4z9xXADd'.replace(/[a-zA-Z]/g,"Q");
			'Q1Q2Q3Q4Q9QQQQQ'
			"2016-09-12".repalce(/[0-9]-/g,"A");
			"AAAAAAAAAA"

##### 预定义类 


|字符|等价类|含义|
|--|:-:|:--:|
|.|[^\r\n]|除了回车符和换行符之外的所有字符|
|\d|[0-9]|数字字符|
|\D|[^0-9]|非数字字符|
|\s|[\t\n\xOB\f\r]|空白字符|
|\S|[^\t\n\xOB\f\r]|非空白字符|
|\w|[a-zA-Z_0-9]|(单词字符)字母数字下划线
|\W|[^a-zA-Z_0-9]|非单词字符|

		匹配一个 ab+ 数字+ 任意字符 的字符串
		ab[0-9][^\r\n];
		ab\d.

####### 边界
###### 正则表达式还提供了几个常用的边界匹配字符

|字符|含义|
|-|-|
|^|以xxxxxx开始|
|$|以xxxxxx结束|
|\b|单词边界|
|\B|非单词边界|

			'This is a boy'.replace(/is/g, '0');
			"Th0 0 a boy" ;
			'This is a boy'.replace(/\bis\b/g, '0');
			"This 0 a boy";
			'This is a boy'.replace(/\Bis\b/g, '0');
			"Th0 is a boy"	
			
					"@123@abc@'.replace(/@./g,"Q");
					"Q23Qbc@";
					"@123@abc@'.replace(/^@./g,"Q");
				     "Q23@abc@"
					"@123@abc@'.replace(/.@/g,"Q");
					"@12QabQ"
					"@123@abc@'.replace(/.@$/g,"Q");
					"@123@abQ"

				      "
					@123
					@456
					@789
					".repalce(/^@\d/g,"X")
					"
					X23
					@456
					@789
					"
					    "
					@123
					@456
					@789
					".repalce(/^@\d/gm,"X")
					"
					X23
					X56
					X89
					"

				
#####量词
- 我们 希望一个连续匹配出现n次数字的字符串
		\d\d\d\d\d\d\d\d\d\d\\d\d\d\d\d\d\d\d\d

|字符|含义|
|--|--|
|?|出现零次或者一次(最多出现一次)|
|+|出现一次或者多次(至少出现一次)|
|*|出现零次或者多次(任意次)|
|{n}|出现n次|
|{n,m}|出现n到m次|
|{n,}|至少出现n次|



##### JavaScript 贪婪模式 与非贪婪模式
- \d{3,6}
- 尽可能多的匹配 直到匹配失败;
			'12345678'.replace(/\d{3,6}/g,"X");
			"X78"
 	
###### 非贪婪模式
- 让正则表达式尽可能少的匹配,也就是说一旦成功匹配不再继续尝试就是非贪婪模式;
- 做法简单,在量词后加上  ? 即可;
			-'1234567890'.match(/\d{3,5}?/g);
			- ["123","456","789"];
			
			- '12345678'.replace(/\d{3,6}/g,"x");
			- x78 	
			
			- '12345678'.replace(/\d{3,6}?/g,"x");
			- xx78 


##### 分组
- 匹配 字符串Byron 连续出现3次的场景;
          		Byron{3} --------->n 连续出现3次
- 使用( )可以达到分组的功能,使用量词作用于分组;
			(Byron){3}---------->整个单词出现3次
			
			'a1b2c3d4'.replace(/[a-z]\d{3}/g,"X");
			'a1b2c3d4'
			
			'a1b2c3d4'.replace(/([a-z]\d){3}/g,"X");
			'Xd4'

##### 或

使用 | 可以达到或的效果
- Byron | Casper	
- Byr(on|Ca)sper
			- ByronCasper.replace(/Byron | Casper/g,'X');
			-  "XX"
			 -ByronsperByrCasper.repalce(/Byr(on|Ca)sper/g,"X");
			 - "XX"	

##### 反向引用
- 2015-12-25 => 12/25/2015
		-                                                成了一个变量 
		-"2015-12-25".replace(/\d{4}-\d{2}-\d{2}/g,"$2$3$1");

		-"2015-12-25".replace(/(\d{4})-(\d{2})-(\d{2})/g,"$2/$3/$1");
[慕课网学习正则笔记](http://www.imooc.com/video/12528/0)